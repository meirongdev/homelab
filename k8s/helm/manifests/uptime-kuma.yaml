---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: uptime-kuma-data
  namespace: personal-services
  annotations:
    argocd.argoproj.io/sync-options: Prune=false
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: nfs-client
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: uptime-kuma
  namespace: personal-services
  labels:
    app: uptime-kuma
spec:
  replicas: 1
  selector:
    matchLabels:
      app: uptime-kuma
  template:
    metadata:
      labels:
        app: uptime-kuma
    spec:
      containers:
        - name: uptime-kuma
          image: louislam/uptime-kuma:1
          ports:
            - containerPort: 3001
              name: http
          resources:
            requests:
              cpu: 50m
              memory: 128Mi
            limits:
              memory: 256Mi
          volumeMounts:
            - name: data
              mountPath: /app/data
          livenessProbe:
            httpGet:
              path: /
              port: 3001
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 3001
            initialDelaySeconds: 10
            periodSeconds: 5
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: uptime-kuma-data
---
apiVersion: v1
kind: Service
metadata:
  name: uptime-kuma
  namespace: personal-services
spec:
  type: ClusterIP
  selector:
    app: uptime-kuma
  ports:
    - port: 3001
      targetPort: 3001
      name: http
---
# Provisioner script — creates admin account + all monitors on first deploy
apiVersion: v1
kind: ConfigMap
metadata:
  name: uptime-kuma-provisioner
  namespace: personal-services
data:
  provision.py: |
    #!/usr/bin/env python3
    import os, sys, time, urllib.request

    UPTIME_KUMA_URL = os.environ.get("UPTIME_KUMA_URL", "http://uptime-kuma:3001")
    USERNAME = os.environ.get("ADMIN_USERNAME", "admin")
    PASSWORD = os.environ["ADMIN_PASSWORD"]

    MONITORS = [
        {"name": "Homepage",       "url": "https://home.meirong.dev"},
        {"name": "Calibre-Web",    "url": "https://book.meirong.dev"},
        {"name": "Grafana",        "url": "https://grafana.meirong.dev"},
        {"name": "HashiCorp Vault","url": "https://vault.meirong.dev"},
        {"name": "IT-Tools",       "url": "https://tool.meirong.dev"},
        {"name": "Stirling-PDF",   "url": "https://pdf.meirong.dev"},
        {"name": "Squoosh",        "url": "https://squoosh.meirong.dev"},
        {"name": "ArgoCD",         "url": "https://argocd.meirong.dev"},
        {"name": "Kopia Backup",   "url": "https://backup.meirong.dev"},
    ]

    def wait_ready(timeout=120):
        deadline = time.time() + timeout
        while time.time() < deadline:
            try:
                urllib.request.urlopen(UPTIME_KUMA_URL, timeout=5)
                print("Uptime Kuma is ready.")
                return
            except Exception:
                print("Waiting for Uptime Kuma...")
                time.sleep(5)
        print("ERROR: Uptime Kuma not ready after timeout", file=sys.stderr)
        sys.exit(1)

    wait_ready()

    from uptime_kuma_api import UptimeKumaApi, MonitorType
    api = UptimeKumaApi(UPTIME_KUMA_URL)

    try:
        api.setup(username=USERNAME, password=PASSWORD)
        print("Admin account created.")
    except Exception as e:
        print(f"Setup failed (likely already exists), logging in: {e}")
        api.login(username=USERNAME, password=PASSWORD)
        print("Logged in.")

    existing = {m["name"] for m in api.get_monitors()}
    print(f"Existing monitors: {existing or '(none)'}")

    for m in MONITORS:
        if m["name"] in existing:
            print(f"  skip  {m['name']}")
            continue
        api.add_monitor(type=MonitorType.HTTP, name=m["name"], url=m["url"], interval=60)
        print(f"  added {m['name']} -> {m['url']}")

    api.disconnect()
    print("Provisioning complete.")
---
# ArgoCD PostSync hook — runs after every sync, idempotent
apiVersion: batch/v1
kind: Job
metadata:
  name: uptime-kuma-provisioner
  namespace: personal-services
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      containers:
        - name: provisioner
          image: python:3.12-slim
          command: ["/bin/sh", "-c"]
          args:
            - pip install --quiet uptime-kuma-api==1.2.1 && python /scripts/provision.py
          env:
            - name: UPTIME_KUMA_URL
              value: "http://uptime-kuma.personal-services.svc:3001"
            - name: ADMIN_USERNAME
              valueFrom:
                secretKeyRef:
                  name: uptime-kuma-admin
                  key: username
            - name: ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: uptime-kuma-admin
                  key: password
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      volumes:
        - name: scripts
          configMap:
            name: uptime-kuma-provisioner
